现在有一个需求，需要将十万条数据依次插入页面：

```
<ul id="container"></ul>
```

```javascript
// 记录任务开始时间
let now = Date.now();
// 插入十万条数据
const total = 100000;
// 获取容器
let ul = document.getElementById('container');
// 将数据插入容器中
for (let i = 0; i < total; i++) {
    let li = document.createElement('li');
    li.innerText = i
    ul.appendChild(li);
}

console.log('JS运行时间：',Date.now() - now);
setTimeout(()=>{
  console.log('总运行时间：',Date.now() - now);
},0)
//JS运行时间： 157
//time1.html:25 总运行时间： 4892
```

浏览器有着肉眼可见的卡顿，平凡刷新甚至会卡死。

这里浏览器渲染的时间问题需要搞一下

对于一次性插入大量数据的情况，一般有两种做法，时间分片和虚拟列表。





#### 时间分片

##### 定时器

 使用`setTimeout`来实现分批渲染 

```javascript
// 记录任务开始时间
let now = Date.now();
// 插入十万条数据
const total = 100000;
//需要插入的容器
let ul = document.getElementById('container');

// 一次插入 20 条
let once = 20;
//总页数
let page = total/once
//每条记录的索引
let index = 0;
//循环加载数据

function loop(curTotal,curIndex){
    if(curTotal <= 0){
        return false;
    }
    //每页多少条
    let pageCount = Math.min(curTotal , once);
    setTimeout(()=>{
        for(let i = 0; i < pageCount; i++){
            let li = document.createElement('li');
            li.innerText = curIndex + i
            ul.appendChild(li)
        }
        loop(curTotal - pageCount,curIndex + pageCount)
    },0)
}
loop(total,index);
```

这里实际上就是一个分页渲染，首先渲染前面20条数据，随后重新计算剩余总条数，递归调用loop函数再依次渲染，知道剩余总条数小于等于0。这里不管再怎么刷新，浏览器会非常顺畅。

然而这种方法快速滚动时会出现白屏或闪屏，主要因为`setTimeout`的执行时间并不是确定的。在JS中，`setTimeout`任务被放进事件队列中，只有主线程执行完才会去检查事件队列中的任务是否需要执行，因此`setTimeout`的实际执行时间可能会比其设定的时间晚一些。

刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而`setTimeout`只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。

在`setTimeout`中对dom进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就可能导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素，从而导致丢帧现象。 

#####  requestAnimationFrame 

>  **`window.requestAnimationFrame()`** 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行 

```javascript
// 记录任务开始时间
let now = Date.now();
//需要插入的容器
let ul = document.getElementById('container');
// 插入十万条数据
let total = 100000;
// 一次插入 20 条
let once = 20;
//总页数
let page = total/once
//每条记录的索引
let index = 0;
//循环加载数据
function loop(curTotal,curIndex){
    if(curTotal <= 0){
        return false;
    }
    //每页多少条
    let pageCount = Math.min(curTotal , once);
    window.requestAnimationFrame(function(){
        for(let i = 0; i < pageCount; i++){
            let li = document.createElement('li');
            li.innerText = curIndex + i 
            ul.appendChild(li)
        }
        loop(curTotal - pageCount,curIndex + pageCount)
    })
}
loop(total,index);
```

这种快速滚动也不会出现白屏或者闪屏，因为`requestAnimationFrame`方法会在每次刷新页面时就会主动调用回调函数，就是我们的分页渲染。

##### DocumentFragment

>  **`DocumentFragment`，文档片段**接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 [`Document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document) 使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的[重新渲染](https://developer.mozilla.org/zh-CN/docs/Glossary/Reflow)，且不会导致性能等问题。 

#### 虚拟列表

