##### 瀑布流布局

- 横向瀑布流

使用flex布局来实现：

```html
<div class="main">
    <div class="item">
        <img src="./imgs/1.jpg" alt="">
    </div>
    <div class="item">
        <img src="./imgs/2.jpg" alt="">
    </div>
    <div class="item">
        <img src="./imgs/3.jpg" alt="">
    </div>
    <div class="item">
        <img src="./imgs/4.jpg" alt="">
    </div>
    <div class="item">
        <img src="./imgs/5.jpg" alt="">
    </div>
    <div class="item">
        <img src="./imgs/6.jpg" alt="">
    </div>
</div>
```

```css
.main{
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}
.main .item{
    flex-grow: 1;
    height: 200px;
    /* flex-basis: 200px; */
}
.main .item img{
    width:100%;
    height:100%;
    object-fit: cover;
    display: block;
}
```

这里再给每个图片动态设置一个flexBasis：

```javascript
var items = document.querySelectorAll('.item');
for(var i=0;i<items.length;i++){
    items[i].style.flexBasis = Math.random() * 200 + 200 + 'px';
}
```

- 竖向瀑布流

  - Multi-Columns 多栏布局

    >  **CSS多列布局（CSS Multi-column Layout）**是一种定义了多栏布局的模块，可支持在布局中建立列（column）的数量，以及内容如何在列之间流动（flow）、列之间的间距（gap）大小，以及列的分隔线（column rules）。 

    详细可以查看[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Columns)，这种比js动态计算要简单的多。

    ```css
    .main{
        /* column-count: 4; */
        column-width: 300px;
        column-gap: 20px;
        column-rule: 1px gray dashed;
    }
    h1{
        column-span: all;
        text-align: center;
    }
    .main .item img{
        width:100%;
        height:100%;
        object-fit: cover;
        display: block;
    }
    ```

    

  - js动态计算

    ```html
    <div class="container">       
    </div>
    <button class="more-btn">加载更多</button>
    ```

    ```css
    .container{
        display: flex;
        gap: 10px;
        align-items: flex-start;
    }
    .item-col{
        flex-basis: 300px;
        flex-grow: 1;
    }
    .item-box{
        padding-top:10px;
        break-inside: avoid;
    }
    .item-box img{
        width:100%;
        height:100%;
        object-fit: cover;
        display: block;
    }
    .more-btn{
        display: block;
        margin: 30px auto;
        padding: 20px;
        font-size: 30px;
    }
    ```

    ```javascript
    var container = document.querySelector('.container');
    var itemBox = document.getElementsByClassName('item-box');
    var moreBtn = document.querySelector('.more-btn');
    var now = 0;
    var cols = Math.floor(window.innerWidth / 300);
    
    for(var i=0;i<cols;i++){
        var itemCol = document.createElement('div');
        itemCol.className = 'item-col';
        container.append(itemCol);
    }
    
    (function(){
        var _arg = arguments;
        if(now === 15){
            return;
        }
        now++;
        var itemBox = document.createElement('div');
        var itemImg = document.createElement('img');
        itemBox.className = 'item-box';
        itemImg.src = `./imgs/${now}.jpg`;
        itemBox.append(itemImg);
        itemImg.onload = function(){
            minCols().append(itemBox);
            _arg.callee();     
        };
    })();
    
    function minCols(){
        var itemCols = document.querySelectorAll('.item-col');
        var arr = [...itemCols];
        arr.sort(function(c1,c2){
            return c1.offsetHeight - c2.offsetHeight;
        });
        return arr[0];
    }
    
    window.onresize = function(){
        var changeCols = Math.floor(window.innerWidth / 300);
        if( changeCols === cols ){
            return;
        }
        cols = changeCols;
        var itemBoxs = document.querySelectorAll('.item-box');
        container.innerHTML = '';
        for(var i=0;i<changeCols;i++){
            var itemCol = document.createElement('div');
            itemCol.className = 'item-col';
            container.append(itemCol);
        }
        var itemCols = document.querySelectorAll('.item-col');
      
        for(var i=0;i<itemBoxs.length;i++){
            minCols().append(itemBoxs[i]);  
        }
    };
    
    moreBtn.onclick = function(){
        var itemCols = document.querySelectorAll('.item-col');
        var now = 14;
        
        (function(){
            var _arg = arguments;
            if(now === 20){
                return;
            }
            now++;
            var itemBox = document.createElement('div');
            var itemImg = document.createElement('img');
            itemBox.className = 'item-box';
            itemImg.src = `./imgs/${now}.jpg`;
            itemBox.append(itemImg);
            itemImg.onload = function(){
                minCols().append(itemBox);
                _arg.callee();     
            };
        })();
    
    };
    ```

    这里首先根据屏幕的宽度来动态计算列数，然后计算最高度低的列来放照片。核心代码就是minCols函数，他拿到所有的列，然后用offsetHeight来进行一个排序，然后返回高度最低的一列，将创建的图片放到这一列，然后通过_arg.callee()不断的重复这一过程。


