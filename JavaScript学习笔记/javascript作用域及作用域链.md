###### javascript作用域及执行上下文

###### 1.作用域

先看一个经典的例子

```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope(); // local scope
```

打印的是`local scope`,而不是`global scope`,虽然f函数调用在外部，可是javascript采用的是此词作用域，也就是静态作用域，函数的作用域在函数定义时就确认了的。javascriot权威指南也是这样描述的

>  JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 

###### 2.执行上下文

javascript在执行代码时，遇到全局代码、函数代码和eval代码时，就会创建一个执行上下文，javascript引擎通过创建一个执行上下文栈来管理执行上下文。  当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。

一个执行上下文的生命周期可以分为两个阶段：创建阶段和代码执行阶段。创建阶段中执行上下文会分别建立变量对象、作用域链和确定this的指向。而在代码执行阶段就会完成变量赋值、函数引用以及执行其他代码。

 每个执行上下文都有三个重要的属性，变量对象、作用域链和this。 

1. 变量对象

   变量对象是执行上下文相关的数据作用域，存储了在上下文中定义变量和函数申明。在全局上下文中，变量对象就是window，全局属性和js静态方法都定义在window对象上；函数上下文是由引擎实现的，无法在js环境中访问的，只有进入一个执行上下文中，变量对象才会被激活，对应的变量对象上的属性才可以被访问。

2. 作用域链

   当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

   函数内部有一个 [[scope]] 属性，当函数创建时，就会保存着父级变量的变量对象，作用域链通过 [[scope]] 属性关联起来，形成完成的作用域链。

3. this

   

   