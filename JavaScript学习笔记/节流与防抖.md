## JavaScript---节流与防抖

> 节流与防抖的作用都是防止函数多次调用。区别在于，假如用户一直触发这个函数，且每次触发函数的间隔小于阙值，防抖的情况下只会调用一次，而节流会每隔一定时间调用函数。

###### 函数防抖

> 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

```html
<!DOCTYPE html>
<html>
<head>
	<title>节流与防抖</title>
	<meta charset="utf-8">
	<style>
	    #container{
	        width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #444; font-size: 30px;
	    }
    </style>
</head>
<body>
 <div id="container"></div>
 <script type="text/javascript">
	var count = 1;
	var container = document.getElementById('container');

	function getUserAction() {
	    container.innerHTML = count++;
	};

	// container.onmousemove = getUserAction;
	container.onmousemove = debounce(getUserAction, 1000);

	function debounce(func, wait) {
	    var timeout;
	    return function () {
	        clearTimeout(timeout)
	        timeout = setTimeout(func, wait);
	    }
	}
</script>
</body>
</html>
```

这里核心思路就是建立一个定时器，重写onmousemove方法，一旦触发onmousemove，先清除定时器，随后再开一个定时器，指定时间后执行函数。这就实现了一个简易的防抖，指定时间内重复触发函数只会执行一次。已经很好的解决了高频重复触发的问题，但因为直接重写了onmousemove函数，this与event均丢失了。

先解决this指向问题，正常在onmousemove函数中，this指向的应该是调用函数的对象，也就是container，因为在debounce中返回了真正重写onmousemove的函数，形成了一个闭包，导致this丢失。指定this指向的方法有apply与call，用法差别只在参数，call需要的是一个数组，这里就用apply。

修改后的debounce函数为：

```javascript
function debounce(func, wait) {
    var timeout;
    return function () {
        var context = this;
        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context)
        }, wait);
    }
}
```

解决event参数，正常在onmousemove函数中有一个event，指向当前的事件对象。因为debounce函数返回的是一个匿名函数，可以通过arguments属性来获取参数，该属性是一个由函数参数组成的类数组。

修改后的debounce：

```javascript
function debounce(func, wait) {
    var timeout;

    return function () {
        var context = this;
        var args = arguments;

        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context, args)
        }, wait);
    }
}
```

完整代码：

###### 函数节流

> 规定在一个单位时间内，只能触发一次函数。如果这个函数单位时间内触发多次函数，只有一次生效。

但是