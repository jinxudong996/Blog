## vue源码系列学习---双向绑定

这些算是vue技术栈的面试基本考题了，我也背过，无非就是Object.defineProperty函数的set与get函数，现在详细的学习下。

```JavaScript
function defineReactive (obj, key, val) {
    Object.defineProperty(obj, key, {
        enumerable: true,       /* 属性可枚举 */
        configurable: true,     /* 属性可被修改或删除 */
        get: function reactiveGetter () {
            return val;        
        },
        set: function reactiveSetter (newVal) {
            if (newVal === val) return;
            console.log('更新了视图。。。' + newVal);
        }
    });
}

function observer (value) {
    if (!value || (typeof value !== 'object')) {
        return;
    }

    Object.keys(value).forEach((key) => {
        defineReactive(value, key, value[key]);
    });
}

class Vue {
    constructor(options) {
        this._data = options.data;
        observer(this._data);
    }
}

let o = new Vue({
    data: {
        test: "I am test."
    }
});
o._data.test = "hello,world.";

```

let o  = new Vue({...})，当实例化一个Vue类时，就会执行构造函数，先绑定一个_data属性，该属性是一个由Vue实例化时传入的一个对象的引用，再传入observer()函数，该函数对传入的对象进行遍历，依次传入defineReactive()，defineReactive()函数里封装了Object.defineProperty()，传入了三个参数，需绑定的对象，以及对象属性的key和value，当需绑定的对象中的属性发生了改变，就会触发set函数，执行更新视图的操作。

这里监听了



网上看了一个例子，是一个简单的vue框架，能够实现简易的v-model指令，现在系统的学习下。例子使用的是啥啊，感觉自己有点小矫情啊，

接下来自己手写一个实例，更详细的学习这些细节。

```JavaScript
let 
```





vue中实现双向绑定原理就是数据劫持和发布订阅模式

发布订阅模式就是定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当对象发生改变时，所有依赖于它的对象都将得到通知。

数据劫持就是利用JavaScript的访问器属性，当对对象的属性进行赋值时，Object.defineProperty就可以通过set()方法劫持到数据的变化，然后通知发布者去通知所有的观察者，观察者收到通知以后，就会更新视图。

在实例化vue时，官网时这样写的

```JavaScript
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
```

ES6新加的Class本质也就是函数原型那些东西，这里就用函数来实现这个迷你vue。

需要一个构造函数来接受实例化vue所传入的参数，节点和data数据。

```javascript
function Vue(options) {
    this.$el = options.el
    this.$data = options.data
}

var app = new Vue({
    el: '#app',
    data: {
        message: 'Hello Vue!'
    }
})
```

在使用vue时，经常会使用一些vue指令，比如双向绑定的v-model，如何识别这些指令呢，就用到了模板编译。编译原理就是将传入节点的所有子节点进行遍历，根据子节点的类型进行区分，如果是元素节点，就进行元素节点进行编译，如果时文本节点，就进行文本节点编译。并且，如果是元素节点，就对该元素进行递归编译，继续遍历该元素节点的子节点。



