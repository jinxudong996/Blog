##### performance工具

###### 火焰图介绍

perf（performance的缩写）是linux系统原生提供的性能分析工具，会返回CPU正在执行的函数名以及调用栈。而火焰图就是基于perf结果产生的SVG图片，用来展示CPU的调用栈。

Chrome浏览器可以生成页面脚本的火焰图，用来进行CPU分析。打开开发者工具，切换到Performance面板，点击录制，开始记录数据，等待一段时间后，停止录制，开发者工具会显示一个时间轴，下方就是火焰图。

![](E:\study\blog\blog\vue学习\img\fire.png)

**这个火焰图是倒置的，调用栈最顶端的函数在最下方，X轴也就是时间轴。**

在火焰图的左侧，有着Network、Main和GPU等，而Main这部分就是网页的主线程，也就是执行Event Loop部分。

可以用鼠标不停的滑动缩放，可以看到每间隔7ms就会执行一个Task，而我笔记本屏幕的144HZ的，也就是1s刷新144次，每次就是7ms

![](C:\Users\Thomas东\AppData\Roaming\Typora\typora-user-images\1684151548313.png)

在这里我们可以看到在每个Task中，首先开始的就是Animation Frame Fired，表示浏览器已经执行了一个动画帧，在Task末尾有一个requestAnimationFrame，在[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame)中是这样介绍的：

> window.requestAnimationFrame()告诉浏览器--你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数来更新动画，方法传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。

同时我们可以看到有一些被标红的Task，在Performance中，超过50ms就会被认为是Long Task，会被标红，以我目前的屏幕刷新帧率来看，50ms就跨越了7帧了，一般在做新能分析时，就是要找到这些Long Task，然后优化他。

当我们把火焰图缩小一点，就可以看到每个Task之间会有一些时间间隙的

![1684153161761](C:\Users\Thomas东\AppData\Roaming\Typora\typora-user-images\1684153161761.png)

那些间隙就是执行requestIdleCallback的，[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)上是这样介绍的：

>  **`window.requestIdleCallback()`** 方法插入一个函数，这个函数将在浏览器空闲时期被调用。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间`timeout`，则有可能为了在超时前执行函数而打乱执行顺序。 

之前在看到这两个api时会有一些疑惑，这俩api有啥区别呢，看了上面哪个图之后，我明白了，这是两个不同维度的东西，在火焰图上一个在X轴方向，一个在Y轴方向，requestAnimationFrame是在每个Task中最先调用的，而requestIdleCallback是在每个Task间隙调用的（如果有的话）。

**宏任务与微任务的执行顺序---之后学习下**

###### 性能优化例子

上面我们学习了用Performance查看火焰图，里面有句话：在做性能分析时就是要找到Long Task，然后优化它。这里做一个实例，进一步加深理解。

准备了这样一段代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>worker performance optimization</title>
</head>
<body>
    <script>
        function a() {
           b();
        }
        function b() {
            let total = 0;
            for(let i = 0; i< 10*10000*10000; i++) {
                total += i;
            }
            console.log('b:', total);
        }

        a();
    </script>
    <script>
        function c() {
            d();
        }
        function d() {
            let total = 0;
            for(let i = 0; i< 1*10000*10000; i++) {
                total += i;
            }
            console.log('c:', total);
        }
        c();
    </script>
</body>
</html>
```

打开浏览器Performance面板，查看火焰图：

![1684154761827](C:\Users\Thomas东\AppData\Roaming\Typora\typora-user-images\1684154761827.png)

可以看到有两个Long Task，最下面的面板上有个Botton-Up，可以看到每个Task的调用栈详情，每个函数的最右边也有源码地址，并且给上了代码的耗时情况：

![1684154929171](C:\Users\Thomas东\AppData\Roaming\Typora\typora-user-images\1684154929171.png)

我们优化Long Task的原因就是渲染和JS执行都在主线程，在同一个Event Loop中会互相阻塞，如果JS长时间执行的Task就会阻塞渲染，导致页面卡顿。接下来我们就要优化Long Task。



































